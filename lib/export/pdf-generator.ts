/**
 * PDF document generation for message exports with Unicode support
 */

import jsPDF from 'jspdf';
import { logger } from '@/lib/logger';
import { NotoSansRegularFont } from '@/lib/fonts/NotoSansRegular';

export interface MessageExportData {
  messageId: string;
  content: string;
  role: 'user' | 'assistant' | 'system';
  timestamp: Date;
  sessionName: string;
  agentUsed?: string;
  tags?: string[];
}

export interface PDFGenerationOptions {
  includeMetadata?: boolean;
  includeTimestamp?: boolean;
  includeBranding?: boolean;
  fontSize?: number;
  margin?: number;
}

/**
 * Generate a professionally formatted PDF from message data
 */
export async function generateMessagePDF(
  messageData: MessageExportData,
  options: PDFGenerationOptions = {}
): Promise<Buffer> {
  try {
    const {
      includeMetadata = true,
      includeTimestamp = true,
      includeBranding = true,
      fontSize = 11,
      margin = 20
    } = options;

    logger.info('Generating PDF document', {
      component: 'PDFGenerator',
      messageId: messageData.messageId,
      sessionName: messageData.sessionName
    });

    // Create new PDF document with Unicode support
    const doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Add Unicode font support
    doc.addFileToVFS('NotoSansRegular.ttf', NotoSansRegularFont);
    doc.addFont('NotoSansRegular.ttf', 'NotoSansRegular', 'normal');
    doc.setFont('NotoSansRegular', 'normal');

    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const contentWidth = pageWidth - (margin * 2);

    let yPosition = margin;

    // Add branding header
    if (includeBranding) {
      doc.setFontSize(18);
      doc.setFont('NotoSansRegular', 'normal');
      doc.setTextColor(41, 128, 185); // Professional blue
      doc.text('ðŸ¦† Rubber Ducky Live', margin, yPosition);
      yPosition += 10;

      doc.setFontSize(12);
      doc.setFont('NotoSansRegular', 'normal');
      doc.setTextColor(108, 117, 125); // Gray
      doc.text('AI Conversation Export', margin, yPosition);
      yPosition += 15;

      // Add separator line
      doc.setDrawColor(233, 236, 239);
      doc.setLineWidth(0.5);
      doc.line(margin, yPosition, pageWidth - margin, yPosition);
      yPosition += 10;
    }

    // Add metadata section
    if (includeMetadata) {
      doc.setFontSize(14);
      doc.setFont('NotoSansRegular', 'normal');
      doc.setTextColor(33, 37, 41); // Dark text
      doc.text('Session Information', margin, yPosition);
      yPosition += 8;

      doc.setFontSize(10);
      doc.setFont('NotoSansRegular', 'normal');
      doc.setTextColor(108, 117, 125);

      // Session details
      const sessionInfo = [
        `Session: ${messageData.sessionName}`,
        `Message ID: ${messageData.messageId.slice(-12)}`,
        `Role: ${messageData.role.charAt(0).toUpperCase() + messageData.role.slice(1)}`,
      ];

      if (messageData.agentUsed) {
        sessionInfo.push(`Agent: ${messageData.agentUsed}`);
      }

      if (includeTimestamp) {
        sessionInfo.push(`Exported: ${new Date().toLocaleString()}`);
        sessionInfo.push(`Message Time: ${messageData.timestamp.toLocaleString()}`);
      }

      if (messageData.tags && messageData.tags.length > 0) {
        sessionInfo.push(`Tags: ${messageData.tags.join(', ')}`);
      }

      sessionInfo.forEach(info => {
        doc.text(info, margin, yPosition);
        yPosition += 5;
      });

      yPosition += 10;

      // Add separator line
      doc.setDrawColor(233, 236, 239);
      doc.line(margin, yPosition, pageWidth - margin, yPosition);
      yPosition += 15;
    }

    // Add message content header
    doc.setFontSize(14);
    doc.setFont('NotoSansRegular', 'normal');
    doc.setTextColor(33, 37, 41);

    const roleLabel = messageData.role === 'user' ? 'Your Message' :
                     messageData.role === 'assistant' ? 'AI Response' : 'System Message';
    doc.text(roleLabel, margin, yPosition);
    yPosition += 10;

    // Render markdown content with proper styling
    yPosition = await renderMarkdownContent(doc, messageData.content, margin, yPosition, contentWidth, pageHeight, fontSize);

    // Add footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setFont('NotoSansRegular', 'normal');
      doc.setTextColor(108, 117, 125);

      const footerText = `Generated by Rubber Ducky Live â€¢ Page ${i} of ${pageCount}`;
      const footerWidth = doc.getTextWidth(footerText);
      doc.text(footerText, (pageWidth - footerWidth) / 2, pageHeight - 10);
    }

    // Convert to buffer with proper encoding handling
    const pdfArrayBuffer = doc.output('arraybuffer');
    const pdfBuffer = Buffer.from(pdfArrayBuffer);

    logger.info('PDF generation completed', {
      component: 'PDFGenerator',
      messageId: messageData.messageId,
      pdfSize: pdfBuffer.length,
      pageCount
    });

    return pdfBuffer;

  } catch (error) {
    logger.error('PDF generation failed', {
      component: 'PDFGenerator',
      messageId: messageData.messageId
    }, error);

    throw new Error(`PDF generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Render markdown content with proper styling in PDF
 */
async function renderMarkdownContent(
  doc: jsPDF,
  content: string,
  margin: number,
  startY: number,
  contentWidth: number,
  pageHeight: number,
  baseFontSize: number
): Promise<number> {
  let yPosition = startY;

  // Normalize Unicode content
  const normalizedContent = content.normalize('NFC');

  // Split content into lines for processing
  const lines = normalizedContent.split('\n');

  let inCodeBlock = false;
  let codeBlockContent = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Check if we need a new page
    if (yPosition > pageHeight - margin - 30) {
      doc.addPage();
      yPosition = margin;
    }

    // Handle code blocks
    if (line.startsWith('```')) {
      if (inCodeBlock) {
        // End of code block - render it
        yPosition = renderCodeBlock(doc, codeBlockContent, margin, yPosition, contentWidth, baseFontSize);
        codeBlockContent = '';
        inCodeBlock = false;
      } else {
        // Start of code block
        inCodeBlock = true;
        yPosition += 5; // Add space before code block
      }
      continue;
    }

    if (inCodeBlock) {
      codeBlockContent += line + '\n';
      continue;
    }

    // Handle headers
    if (line.startsWith('###')) {
      yPosition = renderHeader(doc, line.replace(/^###\s*/, ''), margin, yPosition, 3, baseFontSize);
    } else if (line.startsWith('##')) {
      yPosition = renderHeader(doc, line.replace(/^##\s*/, ''), margin, yPosition, 2, baseFontSize);
    } else if (line.startsWith('#')) {
      yPosition = renderHeader(doc, line.replace(/^#\s*/, ''), margin, yPosition, 1, baseFontSize);
    }
    // Handle horizontal rules
    else if (line.trim() === '---' || line.trim() === '***') {
      yPosition = renderHorizontalRule(doc, margin, yPosition, contentWidth);
    }
    // Handle lists
    else if (line.match(/^\s*[-*+]\s/) || line.match(/^\s*\d+\.\s/)) {
      yPosition = renderListItem(doc, line, margin, yPosition, contentWidth, baseFontSize);
    }
    // Handle regular paragraphs
    else if (line.trim() !== '') {
      yPosition = renderParagraph(doc, line, margin, yPosition, contentWidth, baseFontSize);
    }
    // Handle empty lines
    else {
      yPosition += baseFontSize * 0.5; // Add space for empty lines
    }
  }

  return yPosition;
}

/**
 * Render a markdown header with appropriate styling
 */
function renderHeader(doc: jsPDF, text: string, margin: number, yPosition: number, level: number, baseFontSize: number): number {
  const headerSizes = {
    1: baseFontSize + 6, // H1: +6pt
    2: baseFontSize + 4, // H2: +4pt
    3: baseFontSize + 2  // H3: +2pt
  };

  const headerColors = {
    1: [41, 128, 185],   // Blue for H1
    2: [52, 73, 94],     // Dark blue-gray for H2
    3: [85, 85, 85]      // Dark gray for H3
  };

  // Add space before header
  yPosition += baseFontSize * 0.8;

  // Set header styling
  doc.setFontSize(headerSizes[level as keyof typeof headerSizes]);
  doc.setFont('NotoSansRegular', 'normal');
  doc.setTextColor(...(headerColors[level as keyof typeof headerColors] as [number, number, number]));

  // Render header text with bold effect (simulate by slight offset)
  const cleanText = formatInlineMarkdown(text);
  doc.text(cleanText, margin, yPosition);
  doc.text(cleanText, margin + 0.1, yPosition); // Bold effect

  // Add space after header
  yPosition += headerSizes[level as keyof typeof headerSizes] * 0.4 + 8;

  return yPosition;
}

/**
 * Render a code block with styling
 */
function renderCodeBlock(doc: jsPDF, code: string, margin: number, yPosition: number, contentWidth: number, baseFontSize: number): number {
  // Add background rectangle
  doc.setFillColor(248, 249, 250); // Light gray background
  doc.setDrawColor(233, 236, 239); // Border color

  const codeLines = code.trim().split('\n');
  const lineHeight = (baseFontSize - 1) * 0.4;
  const blockHeight = codeLines.length * lineHeight + 12;

  // Draw background
  doc.rect(margin - 5, yPosition - 3, contentWidth + 10, blockHeight, 'FD');

  // Set code font styling
  doc.setFontSize(baseFontSize - 1);
  doc.setFont('NotoSansRegular', 'normal');
  doc.setTextColor(86, 89, 90); // Dark gray for code

  // Render each line of code
  let codeY = yPosition + 6;
  codeLines.forEach(line => {
    doc.text(line, margin, codeY);
    codeY += lineHeight;
  });

  return yPosition + blockHeight + 8;
}

/**
 * Render a horizontal rule
 */
function renderHorizontalRule(doc: jsPDF, margin: number, yPosition: number, contentWidth: number): number {
  yPosition += 8;

  doc.setDrawColor(233, 236, 239);
  doc.setLineWidth(0.5);
  doc.line(margin, yPosition, margin + contentWidth, yPosition);

  return yPosition + 8;
}

/**
 * Render a list item with proper indentation
 */
function renderListItem(doc: jsPDF, line: string, margin: number, yPosition: number, contentWidth: number, baseFontSize: number): number {
  // Calculate indentation level
  const indentMatch = line.match(/^(\s*)/);
  const indentLevel = Math.floor((indentMatch ? indentMatch[1].length : 0) / 2);
  const indent = margin + (indentLevel * 12);

  // Extract bullet/number and text
  const bulletMatch = line.match(/^\s*[-*+]\s+(.*)/) || line.match(/^\s*\d+\.\s+(.*)/);
  const text = bulletMatch ? bulletMatch[1] : line.trim();

  // Set font
  doc.setFontSize(baseFontSize);
  doc.setFont('NotoSansRegular', 'normal');
  doc.setTextColor(33, 37, 41);

  // Add bullet point
  const bullet = line.match(/^\s*\d+\./) ? 'â€¢' : 'â€¢';
  doc.text(bullet, indent, yPosition);

  // Add text content
  const textLines = doc.splitTextToSize(formatInlineMarkdown(text), contentWidth - (indent - margin) - 8);
  let textY = yPosition;

  textLines.forEach((textLine: string) => {
    doc.text(textLine, indent + 8, textY);
    textY += baseFontSize * 0.4;
  });

  return textY + 2;
}

/**
 * Render a regular paragraph with inline formatting
 */
function renderParagraph(doc: jsPDF, text: string, margin: number, yPosition: number, contentWidth: number, baseFontSize: number): number {
  doc.setFontSize(baseFontSize);
  doc.setFont('NotoSansRegular', 'normal');
  doc.setTextColor(33, 37, 41);

  const formattedText = formatInlineMarkdown(text);
  const lines = doc.splitTextToSize(formattedText, contentWidth);

  lines.forEach((line: string) => {
    doc.text(line, margin, yPosition);
    yPosition += baseFontSize * 0.4;
  });

  return yPosition + 4; // Add paragraph spacing
}

/**
 * Process inline markdown formatting (bold, italic, code)
 */
function formatInlineMarkdown(text: string): string {
  return text
    .replace(/\*\*(.*?)\*\*/g, '$1') // Bold (remove markers for now)
    .replace(/\*(.*?)\*/g, '$1')     // Italic (remove markers for now)
    .replace(/`(.*?)`/g, '$1')       // Inline code (remove markers for now)
    .replace(/[""]|"|"/g, '"')       // Smart quotes
    .replace(/['']|'|'/g, "'")       // Smart apostrophes
    .replace(/â€”/g, '--')             // Em dash
    .replace(/â€“/g, '-')              // En dash
    .replace(/â€¦/g, '...')            // Ellipsis
    .replace(/\u00A0/g, ' ');        // Non-breaking space
}

/**
 * Generate PDF with syntax highlighting for code content
 */
export async function generateCodePDF(
  messageData: MessageExportData,
  options: PDFGenerationOptions = {}
): Promise<Buffer> {
  // For now, use the standard PDF generator
  // TODO: Add syntax highlighting support with different fonts/colors
  return generateMessagePDF(messageData, {
    ...options,
    fontSize: 9, // Smaller font for code
  });
}

/**
 * Extract and format message content for PDF with Unicode support
 */
export function formatMessageForPDF(content: string): string {
  // Normalize Unicode characters (NFC normalization)
  let formatted = content.normalize('NFC');

  // Remove HTML tags if present
  formatted = formatted.replace(/<[^>]*>/g, '');

  // Convert markdown-style formatting to plain text
  const boldRegex = /\*\*(.*?)\*\*/g;
  const italicRegex = /\*(.*?)\*/g;
  const inlineCodeRegex = /`(.*?)`/g;
  const codeBlockRegex = /```[\s\S]*?```/g;

  formatted = formatted
    .replace(boldRegex, '$1') // Bold
    .replace(italicRegex, '$1') // Italic
    .replace(inlineCodeRegex, '$1') // Inline code
    .replace(codeBlockRegex, (match) => {
      // Code blocks - preserve formatting
      return match.replace(/```(\w+)?\n?/g, '').replace(/```$/g, '');
    });

  // Handle problematic characters that might not render well
  formatted = formatted
    .replace(/[""]|"|"/g, '"') // Smart quotes to regular quotes
    .replace(/['']|'|'/g, "'") // Smart apostrophes to regular apostrophes
    .replace(/â€”/g, '--') // Em dash to double dash
    .replace(/â€“/g, '-') // En dash to regular dash
    .replace(/â€¦/g, '...') // Ellipsis to three dots
    .replace(/\u00A0/g, ' '); // Non-breaking space to regular space

  return formatted;
}