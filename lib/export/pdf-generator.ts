/**
 * PDF document generation for message exports
 */

import jsPDF from 'jspdf';
import { logger } from '@/lib/logger';

export interface MessageExportData {
  messageId: string;
  content: string;
  role: 'user' | 'assistant' | 'system';
  timestamp: Date;
  sessionName: string;
  agentUsed?: string;
  tags?: string[];
}

export interface PDFGenerationOptions {
  includeMetadata?: boolean;
  includeTimestamp?: boolean;
  includeBranding?: boolean;
  fontSize?: number;
  margin?: number;
}

/**
 * Generate a professionally formatted PDF from message data
 */
export async function generateMessagePDF(
  messageData: MessageExportData,
  options: PDFGenerationOptions = {}
): Promise<Buffer> {
  try {
    const {
      includeMetadata = true,
      includeTimestamp = true,
      includeBranding = true,
      fontSize = 11,
      margin = 20
    } = options;

    logger.info('Generating PDF document', {
      component: 'PDFGenerator',
      messageId: messageData.messageId,
      sessionName: messageData.sessionName
    });

    // Create new PDF document
    const doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const contentWidth = pageWidth - (margin * 2);
    
    let yPosition = margin;

    // Add branding header
    if (includeBranding) {
      doc.setFontSize(18);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(41, 128, 185); // Professional blue
      doc.text('ðŸ¦† Rubber Ducky Live', margin, yPosition);
      yPosition += 10;

      doc.setFontSize(12);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(108, 117, 125); // Gray
      doc.text('AI Conversation Export', margin, yPosition);
      yPosition += 15;

      // Add separator line
      doc.setDrawColor(233, 236, 239);
      doc.setLineWidth(0.5);
      doc.line(margin, yPosition, pageWidth - margin, yPosition);
      yPosition += 10;
    }

    // Add metadata section
    if (includeMetadata) {
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(33, 37, 41); // Dark text
      doc.text('Session Information', margin, yPosition);
      yPosition += 8;

      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(108, 117, 125);

      // Session details
      const sessionInfo = [
        `Session: ${messageData.sessionName}`,
        `Message ID: ${messageData.messageId.slice(-12)}`,
        `Role: ${messageData.role.charAt(0).toUpperCase() + messageData.role.slice(1)}`,
      ];

      if (messageData.agentUsed) {
        sessionInfo.push(`Agent: ${messageData.agentUsed}`);
      }

      if (includeTimestamp) {
        sessionInfo.push(`Exported: ${new Date().toLocaleString()}`);
        sessionInfo.push(`Message Time: ${messageData.timestamp.toLocaleString()}`);
      }

      if (messageData.tags && messageData.tags.length > 0) {
        sessionInfo.push(`Tags: ${messageData.tags.join(', ')}`);
      }

      sessionInfo.forEach(info => {
        doc.text(info, margin, yPosition);
        yPosition += 5;
      });

      yPosition += 10;

      // Add separator line
      doc.setDrawColor(233, 236, 239);
      doc.line(margin, yPosition, pageWidth - margin, yPosition);
      yPosition += 15;
    }

    // Add message content header
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(33, 37, 41);
    
    const roleLabel = messageData.role === 'user' ? 'Your Message' : 
                     messageData.role === 'assistant' ? 'AI Response' : 'System Message';
    doc.text(roleLabel, margin, yPosition);
    yPosition += 10;

    // Add message content
    doc.setFontSize(fontSize);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(33, 37, 41);

    // Split content into lines that fit the page width
    const contentLines = doc.splitTextToSize(messageData.content, contentWidth);
    
    // Add content with page breaks if needed
    for (let i = 0; i < contentLines.length; i++) {
      // Check if we need a new page
      if (yPosition > pageHeight - margin - 20) {
        doc.addPage();
        yPosition = margin;
      }

      doc.text(contentLines[i], margin, yPosition);
      yPosition += fontSize * 0.35; // Line height
    }

    // Add footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(108, 117, 125);
      
      const footerText = `Generated by Rubber Ducky Live â€¢ Page ${i} of ${pageCount}`;
      const footerWidth = doc.getTextWidth(footerText);
      doc.text(footerText, (pageWidth - footerWidth) / 2, pageHeight - 10);
    }

    // Convert to buffer
    const pdfBuffer = Buffer.from(doc.output('arraybuffer'));

    logger.info('PDF generation completed', {
      component: 'PDFGenerator',
      messageId: messageData.messageId,
      pdfSize: pdfBuffer.length,
      pageCount
    });

    return pdfBuffer;

  } catch (error) {
    logger.error('PDF generation failed', {
      component: 'PDFGenerator',
      messageId: messageData.messageId
    }, error);

    throw new Error(`PDF generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Generate PDF with syntax highlighting for code content
 */
export async function generateCodePDF(
  messageData: MessageExportData,
  options: PDFGenerationOptions = {}
): Promise<Buffer> {
  // For now, use the standard PDF generator
  // TODO: Add syntax highlighting support with different fonts/colors
  return generateMessagePDF(messageData, {
    ...options,
    fontSize: 9, // Smaller font for code
  });
}

/**
 * Extract and format message content for PDF
 */
export function formatMessageForPDF(content: string): string {
  // Remove HTML tags if present
  let formatted = content.replace(/<[^>]*>/g, '');
  
  // Convert markdown-style formatting to plain text
  const boldRegex = /\*\*(.*?)\*\*/g;
  const italicRegex = /\*(.*?)\*/g;
  const inlineCodeRegex = /`(.*?)`/g;
  const codeBlockRegex = /```[\s\S]*?```/g;
  
  formatted = formatted
    .replace(boldRegex, '$1') // Bold
    .replace(italicRegex, '$1') // Italic
    .replace(inlineCodeRegex, '$1') // Inline code
    .replace(codeBlockRegex, (match) => {
      // Code blocks - preserve formatting
      return match.replace(/```(\w+)?\n?/g, '').replace(/```$/g, '');
    });

  return formatted;
}