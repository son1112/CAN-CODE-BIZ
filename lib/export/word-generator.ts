/**
 * Word document generation for message exports
 */

import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, BorderStyle } from 'docx';
import { logger } from '@/lib/logger';
import { MessageExportData } from './pdf-generator';

export interface WordGenerationOptions {
  includeMetadata?: boolean;
  includeTimestamp?: boolean;
  includeBranding?: boolean;
  fontSize?: number;
}

/**
 * Generate a professionally formatted Word document from message data
 */
export async function generateMessageWord(
  messageData: MessageExportData,
  options: WordGenerationOptions = {}
): Promise<Buffer> {
  try {
    const {
      includeMetadata = true,
      includeTimestamp = true,
      includeBranding = true,
      fontSize = 11
    } = options;

    logger.info('Generating Word document', {
      component: 'WordGenerator',
      messageId: messageData.messageId,
      sessionName: messageData.sessionName
    });

    const children: Paragraph[] = [];

    // Add branding header
    if (includeBranding) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'ðŸ¦† Rubber Ducky Live',
              bold: true,
              size: 32, // 16pt
              color: '2980B9' // Professional blue
            })
          ],
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 }
        }),
        new Paragraph({
          children: [
            new TextRun({
              text: 'AI Conversation Export',
              size: 24, // 12pt
              color: '6C757D' // Gray
            })
          ],
          spacing: { after: 400 }
        })
      );
    }

    // Add metadata section
    if (includeMetadata) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: 'Session Information',
              bold: true,
              size: 28 // 14pt
            })
          ],
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 200 }
        })
      );

      // Session details
      const sessionInfo = [
        `Session: ${messageData.sessionName}`,
        `Message ID: ${messageData.messageId.slice(-12)}`,
        `Role: ${messageData.role.charAt(0).toUpperCase() + messageData.role.slice(1)}`,
      ];

      if (messageData.agentUsed) {
        sessionInfo.push(`Agent: ${messageData.agentUsed}`);
      }

      if (includeTimestamp) {
        sessionInfo.push(`Exported: ${new Date().toLocaleString()}`);
        sessionInfo.push(`Message Time: ${messageData.timestamp.toLocaleString()}`);
      }

      if (messageData.tags && messageData.tags.length > 0) {
        sessionInfo.push(`Tags: ${messageData.tags.join(', ')}`);
      }

      sessionInfo.forEach(info => {
        children.push(
          new Paragraph({
            children: [
              new TextRun({
                text: info,
                size: 20, // 10pt
                color: '6C757D'
              })
            ],
            spacing: { after: 100 }
          })
        );
      });

      children.push(
        new Paragraph({
          children: [],
          spacing: { after: 400 }
        })
      );
    }

    // Add message content header
    const roleLabel = messageData.role === 'user' ? 'Your Message' :
                     messageData.role === 'assistant' ? 'AI Response' : 'System Message';

    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: roleLabel,
            bold: true,
            size: 28 // 14pt
          })
        ],
        heading: HeadingLevel.HEADING_2,
        spacing: { after: 200 }
      })
    );

    // Add message content
    const formattedContent = formatMessageForWord(messageData.content);
    const contentParagraphs = formattedContent.split('\n').filter(line => line.trim() !== '');

    contentParagraphs.forEach(paragraph => {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: paragraph,
              size: fontSize * 2 // Word uses half-points
            })
          ],
          spacing: { after: 150 }
        })
      );
    });

    // Add footer
    children.push(
      new Paragraph({
        children: [
          new TextRun({
            text: 'Generated by Rubber Ducky Live',
            size: 16, // 8pt
            color: '6C757D',
            italics: true
          })
        ],
        alignment: AlignmentType.CENTER,
        spacing: { before: 800 },
        border: {
          top: {
            style: BorderStyle.SINGLE,
            size: 1,
            color: 'E9ECEF'
          }
        }
      })
    );

    // Create document
    const doc = new Document({
      sections: [
        {
          properties: {
            page: {
              margin: {
                top: 1440, // 1 inch in twips
                right: 1440,
                bottom: 1440,
                left: 1440
              }
            }
          },
          children
        }
      ],
      creator: 'Rubber Ducky Live',
      title: `${messageData.sessionName} - Message Export`,
      description: `Exported message from ${messageData.sessionName}`,
      lastModifiedBy: 'Rubber Ducky Live'
    });

    // Generate buffer
    const wordBuffer = await Packer.toBuffer(doc);

    logger.info('Word document generation completed', {
      component: 'WordGenerator',
      messageId: messageData.messageId,
      documentSize: wordBuffer.length
    });

    return wordBuffer;

  } catch (error) {
    logger.error('Word document generation failed', {
      component: 'WordGenerator',
      messageId: messageData.messageId
    }, error);

    throw new Error(`Word generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Format message content for Word document
 */
export function formatMessageForWord(content: string): string {
  // Remove HTML tags if present
  let formatted = content.replace(/<[^>]*>/g, '');

  // Handle markdown-style formatting
  formatted = formatted
    .replace(/\*\*(.*?)\*\*/g, '$1') // Bold (Word will handle via TextRun formatting)
    .replace(/\*(.*?)\*/g, '$1')     // Italic
    .replace(/`(.*?)`/g, '$1')      // Inline code
    .replace(/```[\s\S]*?```/g, (match) => {
      // Code blocks - preserve with indentation
      const codeContent = match.replace(/```(\w+)?\n?/g, '').replace(/```$/g, '');
      return codeContent.split('\n').map(line => `    ${line}`).join('\n');
    });

  // Clean up extra whitespace while preserving intentional line breaks
  formatted = formatted
    .replace(/\n\s*\n\s*\n/g, '\n\n') // Multiple line breaks to double
    .replace(/^\s+|\s+$/g, '') // Trim start and end
    .replace(/\t/g, '    '); // Convert tabs to spaces

  return formatted;
}

/**
 * Generate Word document with enhanced formatting for code content
 */
export async function generateCodeWord(
  messageData: MessageExportData,
  options: WordGenerationOptions = {}
): Promise<Buffer> {
  // Enhanced version with monospace font for code
  // TODO: Implement code-specific formatting with Courier New font
  return generateMessageWord(messageData, {
    ...options,
    fontSize: 10, // Smaller font for code readability
  });
}