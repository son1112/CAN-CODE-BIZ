#+TITLE: Rubber Ducky Live - Active Product Backlog  
#+DATE: 2025-08-24
#+AUTHOR: Development Team

* Overview
This file tracks **active** future work items, feature requests, improvements, and technical debt for Rubber Ducky Live. Completed items are archived in `COMPLETED_BACKLOG.org`.

* Priority Legend
- ðŸ”´ HIGH: Critical issues, security concerns, breaking bugs
- ðŸŸ¡ MEDIUM: Important features, performance improvements  
- ðŸŸ¢ LOW: Nice-to-have features, minor enhancements
- ðŸ”µ RESEARCH: Investigation needed, proof of concept

* Active Backlog Items

** ðŸ”´ HIGH Priority

*** Record Button Response Lag - Voice Input UI Performance Issue
**** Problem Statement
**PERFORMANCE ISSUE**: The voice recording button experiences noticeable response lag when clicked, impacting user experience during voice input interactions.

**** Specific Issues Identified
- **Button Response Delay**: Noticeable lag between clicking record button and visual feedback
- **User Experience Impact**: Creates uncertainty about whether button press registered
- **Voice Recording Start**: Potential delay in actual recording initiation
- **UI Responsiveness**: Button feels sluggish compared to other interface elements

**** Technical Details
- VoiceInput component may have performance bottlenecks in click handler
- Possible state update delays causing UI lag
- WebSocket connection initialization might block button response
- AssemblyAI token fetch could be causing delay

**** Suspected Root Causes
1. **Heavy Click Handler**: Button click handler may be performing synchronous operations
2. **State Update Blocking**: setState operations might be blocking UI updates
3. **API Call Blocking**: AssemblyAI token generation blocking button response
4. **Component Re-rendering**: Expensive re-renders triggered by button state changes

**** Implementation Approach
**PERFORMANCE OPTIMIZATION REQUIRED:**
1. **Button Response Optimization**
   - Add immediate visual feedback (optimistic UI updates)
   - Move heavy operations to async handlers
   - Implement loading states for better UX

2. **Click Handler Refactoring**
   - Separate immediate UI updates from async operations
   - Use React.startTransition for non-urgent updates
   - Add performance profiling to identify bottlenecks

3. **State Management Improvements**
   - Optimize state structure to minimize re-renders
   - Use useCallback/useMemo for expensive operations
   - Consider moving heavy logic to custom hooks

4. **Testing & Validation**
   - Add performance monitoring for button response times
   - Test on various devices/browsers for consistency
   - User testing to validate improved responsiveness

**** Priority: ðŸ”´ HIGH
**** Complexity: Medium
**** Dependencies: VoiceInput component, AssemblyAI integration
**** Related Files: `app/components/VoiceInput.tsx`, `hooks/useSpeechRecognition.ts`

*** Session Chat Message Order - Change Message Display Order
**** Problem Statement
**UX FEATURE**: Users need the ability to change the order in which messages are displayed within a chat session for better conversation flow and usability.

**** Specific Issues Identified
- **Fixed Message Order**: Messages currently display in a fixed chronological order
- **User Preference**: Different users may prefer different message ordering (newest first vs oldest first)
- **Conversation Flow**: Some debugging/analysis workflows benefit from reverse chronological order
- **Usability**: No option to customize message display to user preference

**** Technical Details
- Messages are currently rendered in chronological order (oldest to newest)
- No UI controls to toggle message order
- Message virtualization may need updates to handle order changes
- Scroll position management needed when order changes

**** Suspected Root Causes
1. **Hard-coded Message Order**: Message rendering assumes chronological order
2. **Missing UI Controls**: No toggle/button to change message order
3. **State Management**: No preference storage for message order setting
4. **Virtualization**: VirtualizedMessageList may need order-aware updates

**** Implementation Approach
**FEATURE DEVELOPMENT REQUIRED:**
1. **UI Controls Implementation**
   - Add message order toggle button to chat interface
   - Design intuitive toggle (newest first â†” oldest first)
   - Position in session header or chat controls area

2. **State Management**
   - Add messageOrder preference to user settings
   - Store preference in localStorage and user preferences API
   - Update ChatInterface to respect order preference

3. **Message Rendering Updates**
   - Update filteredMessages logic to respect order preference
   - Modify VirtualizedMessageList for reverse order support
   - Maintain scroll position during order changes

4. **Preference Persistence**
   - Store message order preference per user
   - Apply preference across all sessions
   - Sync with user preferences API

**** Priority: ðŸ”´ HIGH
**** Complexity: Medium
**** Estimated Time: 3-4 hours
**** Dependencies: None
**** Related Files:
- `app/components/ChatInterface.tsx` - Main message display logic
- `app/components/VirtualizedMessageList.tsx` - Message virtualization
- `contexts/PreferencesContext.tsx` - User preference management
- `app/api/preferences/route.ts` - Preference storage API

**** Acceptance Criteria:
- [ ] Toggle button to switch between newest first / oldest first
- [ ] Message order preference persists across sessions
- [ ] Smooth transition when changing order (no jarring jumps)
- [ ] Scroll position maintained appropriately during order changes
- [ ] Works with message virtualization system
- [ ] Preference stored in user settings

*** Session History Loading Performance - Slow Session List
**** Problem Statement
**PERFORMANCE**: Session history list is slow to load session items, causing poor user experience when navigating between conversations.

**** Specific Issues Identified
- **Slow Session Loading**: Session list takes too long to populate
- **User Experience**: Delay impacts navigation between conversations
- **Performance Impact**: May affect user retention and workflow efficiency

**** Technical Details
- loadSessions API call may be inefficient
- Large session data may be loaded unnecessarily
- Database queries might not be optimized
- React rendering performance could be improved

**** Suspected Root Causes
1. **Database Query Optimization**: Inefficient MongoDB queries loading full session data
2. **API Response Size**: Loading full message content when only metadata needed
3. **React Rendering**: Inefficient list rendering without virtualization
4. **Caching**: No proper caching strategy for session metadata

**** Implementation Approach
**OPTIMIZATION REQUIRED:**
1. **Database Query Optimization**
   - Use projection to load only metadata (name, date, message count)
   - Add proper indexes on userId, createdAt, updatedAt fields
   - Implement pagination for large session lists

2. **API Response Optimization**
   - Create lightweight session metadata API endpoint
   - Separate full session loading from list loading
   - Add caching headers for session lists

3. **Frontend Performance**
   - Implement virtual scrolling for session list
   - Add proper loading states and skeleton screens
   - Cache session metadata in React state/local storage

**** Priority: ðŸ”´ HIGH
**** Complexity: Medium
**** Estimated Time: 4-6 hours
**** Dependencies: None
**** Related Files:
- `/api/sessions/route.ts` - Session list API
- `/contexts/SessionContext.tsx` - Session state management
- `/components/SessionList.tsx` - Session list UI component

**** Acceptance Criteria:
- [ ] Session list loads in <500ms
- [ ] Smooth scrolling with large session lists
- [ ] Proper loading states during fetch
- [ ] Cache session metadata locally
- [ ] Maintain current functionality
   - Ensure useStreamingChat properly loads historical messages

3. **Mobile/Responsive Testing** 
   - Test across different device sizes and orientations
   - Verify CSS container dimensions and overflow handling
   - Check touch scrolling and viewport interactions

**** Priority Level: ðŸ”´ HIGH (CRITICAL - Complete message display failure)
**** Complexity Estimate: Medium (1-2 weeks) - Requires deep debugging of virtualization system
**** Dependencies: VirtualizedMessageList, useStreamingChat, message loading system
**** Acceptance Criteria
- [ ] All messages display correctly in sessions regardless of message count
- [ ] Message virtualization works properly on mobile and desktop
- [ ] Scroll behavior maintains message visibility
- [ ] Long-running sessions display complete message history
- [ ] No blank/empty chat interfaces in active sessions
**** Related Files
- app/components/VirtualizedMessageList.tsx (message virtualization)
- app/components/ChatInterface.tsx (main chat container)
- hooks/useStreamingChat.ts (message loading/state management)
- hooks/useMessageVirtualization.ts (virtualization logic)

*** Session Header State Persistence Bug
**** Problem Statement
**CRITICAL**: When starting a new conversation, session header retains name and details from previously rendered session chat instead of showing current/new session information.

**** Technical Details
- Session header shows stale data from previous session
- Affects new conversation creation user experience
- May indicate state management issues in session context or header component
- Could confuse users about which session they're actually in

**** Implementation Approach
**IMMEDIATE INVESTIGATION REQUIRED:**
1. **Debug Session Header Component**
   - Check state management and prop updates
   - Verify session context is properly updated on route/session changes
   - Ensure header re-renders when new session is created

2. **Session Context Management**
   - Review session switching logic
   - Check for stale state persistence between session changes
   - Verify cleanup when creating new sessions

**** Priority Level: ðŸ”´ HIGH (CRITICAL - State management failure)
**** Complexity Estimate: Simple to Medium (3-5 days)
**** Dependencies: Session context, Header component, Session routing
**** Acceptance Criteria
- [ ] New conversation shows correct session header immediately
- [ ] No stale data from previous sessions persists
- [ ] Session header updates properly on all session changes
**** Related Files
- app/components/SessionHeader.tsx (or similar header component)
- contexts/SessionContext.tsx (session state management)
- Session routing and navigation logic

*** Mobile Navigation Optimization Initiative  
**** Problem Statement
Multiple mobile navigation issues identified that impact user experience:
- Hamburger menu scroll optimization needed
- Hamburger menu not closing properly
- Dark mode switcher missing for mobile
- Sidebar left menu scrollability issues in sections

**** Implementation Approach
Comprehensive mobile navigation overhaul to address all related issues in one cohesive effort.

** ðŸŸ¡ MEDIUM Priority

*** Agent System Feature Updates & Enhancements
**** Problem Statement
Current agent system requires enhancements to improve user experience and functionality:
- Agent selector UI could be more intuitive and responsive
- Need better agent performance monitoring and metrics
- Missing agent creation/editing workflow improvements  
- Agent processing feedback could be enhanced
- Integration with Claude Code sub-agents needs investigation

**** Technical Requirements
- Improve AgentSelector component UX with better loading states
- Add agent performance metrics tracking
- Enhance agent creation modal with better validation
- Implement agent usage analytics and success tracking
- Investigate Claude Code sub-agent integration issues
- Add agent favorites/starred system integration
- Improve agent processing error handling and user feedback

**** Implementation Approaches
1. **UI/UX Enhancements**
   - Redesign AgentSelector with improved visual hierarchy
   - Add loading states and skeleton screens during agent operations
   - Implement better responsive design for mobile agent selection
   
2. **Performance & Monitoring**  
   - Integrate usePerformanceMonitor hook for agent operations
   - Add agent processing time metrics
   - Track agent success/failure rates
   
3. **Feature Improvements**
   - Enhanced agent creation workflow with better validation
   - Agent templates or presets for common use cases
   - Integration with existing stars system for agent favorites
   
4. **Integration Investigation**
   - Research why Claude Code isn't using defined sub-agents properly
   - Improve agent processing feedback and error messages
   - Better integration between custom agents and system agents

**** Priority Level: ðŸŸ¡ MEDIUM
**** Complexity Estimate: Medium to Complex (2-4 weeks)
**** Dependencies: Performance monitoring system, Stars system
**** Acceptance Criteria
- [ ] Agent selector UI is more responsive and intuitive
- [ ] Agent performance metrics are tracked and displayed  
- [ ] Agent creation workflow is streamlined
- [ ] Error handling and feedback is improved
- [ ] Claude Code sub-agent integration issues are resolved
- [ ] Agent favorites system is integrated with stars
**** Related Files
- hooks/useAgents.ts (main agent management hook)
- app/components/AgentSelector.tsx (agent selection UI)
- app/api/agents/route.ts (agent API endpoints)
- hooks/usePerformanceMonitor.ts (performance tracking)

*** UI Low Contrast Text/Background Issues
**** Problem Statement
Critical accessibility and readability issues due to severely low contrast between text and background colors, making content nearly unreadable.

**** Specific Issues Identified
- **Dark Mode "Let's chat about:" Dialogue**: Light gray text on gray background in welcome dialogue bubble
- **Message Content**: "Quack quack! Ready for some classic rubber duck debugging?" text is barely visible in dark mode
- **System Messages**: Welcome/intro messages have insufficient contrast ratios specifically in dark theme

**** Technical Details
- Text is extremely difficult to read in dark mode theme
- Does NOT meet WCAG 2.1 contrast ratio requirements (4.5:1 for normal text, 3:1 for large text)
- Severely impacts users with visual impairments or color vision deficiencies
- Dark theme implementation needs contrast ratio improvements
- Issue appears to be specific to theme-aware styling in welcome dialogue components

**** Implementation Approach
1. **Accessibility Audit**
   - Run automated contrast checking tools
   - Test with WCAG contrast ratio guidelines
   - Identify specific components with contrast issues

2. **Design System Update**
   - Review and update color palette for better contrast
   - Ensure dark mode and light mode both meet accessibility standards
   - Create contrast-compliant color variables

3. **Component Updates**
   - Update affected components with improved color schemes
   - Test across different devices and screen settings
   - Ensure consistent contrast across the entire application

**** Priority Level: ðŸŸ¡ MEDIUM (upgraded due to severe accessibility impact)  
**** Complexity Estimate: Simple to Medium (1-2 weeks)
**** Dependencies: Design system, Theme system
**** Acceptance Criteria
- [ ] All UI components meet WCAG 2.1 contrast requirements
- [ ] Text is clearly readable in both light and dark modes
- [ ] Automated contrast checking passes for all components
- [ ] Manual testing confirms improved readability
**** Related Files
- app/globals.css (global color definitions)
- contexts/ThemeContext.tsx (theme management)
- tailwind.config.js (color system configuration)
- All component files with text/background styling

*** Google OAuth Mobile Configuration Error
**** Problem Statement
Google OAuth fails on first attempt with configuration error, but works on second try on mobile devices.

**** Technical Details
- First authentication attempt: Configuration error
- Second authentication attempt: Success
- Affects mobile users specifically

*** Session History View Count Issue  
**** Problem Statement
Session history view count stays at 0 regardless of actual usage.

**** Technical Details
- View count not incrementing properly
- May be related to session tracking or database updates

*** Click Text Highlighting Feature
**** Problem Statement
Need ability to click on text sections to make them more prominent/highlighted/featured in messages.

**** Implementation Approach
Add interactive text highlighting functionality for better message readability and emphasis.

*** Voice Transcript Status Indicators
**** Problem Statement
Users need visual feedback about the status of their voice transcripts during the speech-to-text process. Currently, there's no clear indication of whether a transcript is waiting to be sent, ready to be sent to the transcriber, or has been sent to the transcriber.

**** Technical Requirements
- Add small color-coded status indicators for voice transcript states
- Red indicator: Transcript waiting to be sent (buffering/silence detection phase)
- Yellow indicator: Ready to be sent to transcriber (silence threshold met)
- Green indicator: Sent to transcriber (processing by AssemblyAI)
- Position indicator near the voice input area for clear visibility

**** Implementation Approach
1. **Status State Management**
   - Track transcript status in useSpeechRecognition hook
   - Create TranscriptStatus enum with WAITING, READY, SENT states
   - Update status based on WebSocket connection and data flow

2. **UI Component**
   - Create TranscriptStatusIndicator component
   - Use small circular indicators with appropriate colors
   - Add tooltips explaining each status
   - Smooth transitions between states

3. **Integration Points**
   - Update ChatInterface to include status indicator
   - Position near microphone button or input area
   - Ensure mobile-responsive sizing and positioning

**** Priority Level: ðŸŸ¡ MEDIUM
**** Complexity Estimate: Simple (2-3 days)
**** Dependencies: AssemblyAI integration, useSpeechRecognition hook
**** Acceptance Criteria
- [ ] Status indicator shows red when recording but not ready to send
- [ ] Status indicator shows yellow when silence detected and ready to send
- [ ] Status indicator shows green when transcript sent to AssemblyAI
- [ ] Indicators have clear tooltips explaining their meaning
- [ ] Mobile-responsive design implemented
**** Related Files
- hooks/useSpeechRecognition.ts (main voice recognition hook)
- app/components/ChatInterface.tsx (main chat UI)
- app/components/VoiceInput.tsx (voice input component)

*** ElevenLabs Text-to-Speech Integration
**** Problem Statement
Users want the ability to have AI responses read aloud using natural-sounding voices. ElevenLabs provides high-quality text-to-speech capabilities that would enhance the conversational experience, especially for accessibility and hands-free usage.

**** Technical Requirements
- Integrate ElevenLabs API for text-to-speech conversion
- Add play/pause controls for AI message audio playbook
- Support multiple voice options from ElevenLabs
- Implement audio queue management for streaming responses
- Add user preferences for auto-play and voice selection

**** Implementation Approach
1. **API Integration**
   - Set up ElevenLabs API client with authentication
   - Create TTS service module for API calls
   - Handle streaming audio responses
   - Implement error handling and fallbacks

2. **Audio Player Component**
   - Create AudioPlayer component for message playback
   - Add play/pause/stop controls
   - Show audio loading and progress indicators
   - Support playback speed adjustment

3. **User Preferences**
   - Add TTS settings to user preferences
   - Voice selection dropdown with preview
   - Auto-play toggle for new messages
   - Volume and speed controls

4. **Performance Considerations**
   - Cache audio for repeated playback
   - Implement audio preloading for better UX
   - Handle concurrent audio requests efficiently
   - Clean up audio resources properly

**** Priority Level: ðŸŸ¡ MEDIUM
**** Complexity Estimate: Medium (1-2 weeks)
**** Dependencies: User preferences system, message rendering
**** Acceptance Criteria
- [ ] ElevenLabs API successfully integrated
- [ ] Audio playback controls added to AI messages
- [ ] Multiple voice options available
- [ ] User preferences for TTS implemented
- [ ] Smooth playback of streaming responses
- [ ] Proper error handling for API failures
- [ ] Mobile-responsive audio controls
**** Related Files
- lib/elevenlabs.ts (new - API client)
- app/components/AudioPlayer.tsx (new - audio controls)
- app/components/MessageItem.tsx (integrate audio player)
- contexts/PreferencesContext.tsx (TTS preferences)
- app/api/tts/route.ts (new - TTS API endpoint)

*** Feature Flags System
**** Problem Statement
The application needs a robust feature flags system to enable controlled rollouts, A/B testing, feature toggles for different environments, and the ability to quickly disable features in production without code deployments. Currently, there's no systematic way to control feature availability across different users, environments, or deployment stages.

**** Technical Requirements
- Dynamic feature flag management without code deployments
- User-based, role-based, and percentage-based flag targeting
- Environment-specific flag configurations (dev, staging, production)
- Real-time flag updates without application restart
- Admin interface for managing flags
- Analytics and metrics for flag usage
- Integration with existing user preferences system

**** Implementation Approach
1. **Core Flag System**
   - Create FeatureFlag model with flag definitions
   - Implement flag evaluation engine with targeting rules
   - Add caching layer for performance (Redis or in-memory)
   - Create flag configuration API endpoints

2. **Flag Management Interface**
   - Build admin dashboard for flag management
   - Add flag creation, editing, and deletion functionality
   - Implement targeting rules UI (user groups, percentages, etc.)
   - Add flag status monitoring and usage analytics

3. **Client Integration**
   - Create useFeatureFlag hook for React components
   - Add FeatureFlag component for conditional rendering
   - Implement flag prefetching and caching on client
   - Add debugging tools for development

4. **Common Feature Flags**
   - NEW_VOICE_TRANSCRIPT_INDICATORS (voice status indicators)
   - ELEVENLABS_TTS_INTEGRATION (text-to-speech features)
   - ENHANCED_EXPORT_OPTIONS (advanced export features)
   - CONTINUOUS_MODE_V2 (improved continuous conversation)
   - ADVANCED_AGENT_FEATURES (power agent enhancements)

**** Priority Level: ðŸŸ¡ MEDIUM  
**** Complexity Estimate: Medium to Complex (2-3 weeks)
**** Dependencies: User authentication, admin roles, preferences system
**** Acceptance Criteria
- [ ] Feature flags can be created and managed via admin interface
- [ ] Flags support user-based and percentage-based targeting
- [ ] Real-time flag updates work without app restart
- [ ] useFeatureFlag hook provides clean component integration
- [ ] Flag usage analytics and monitoring implemented
- [ ] Environment-specific flag configurations supported
- [ ] Performance impact is minimal (< 5ms per flag check)
- [ ] Rollback capability for quickly disabling problematic flags
**** Related Files
- models/FeatureFlag.ts (new - flag definitions and targeting)
- contexts/FeatureFlagsContext.tsx (new - flag state management)
- hooks/useFeatureFlag.ts (new - flag consumption hook)
- app/components/FeatureFlag.tsx (new - conditional rendering)
- app/admin/feature-flags/page.tsx (new - management interface)
- app/api/feature-flags/route.ts (new - flag management API)
- lib/featureFlags.ts (new - flag evaluation engine)
- lib/flagCache.ts (new - caching and performance)

*** Message Queue System for Session Chats
**** Problem Statement
The current session chat system processes messages synchronously, which can lead to blocking, race conditions, and poor user experience during high-load scenarios. A queueing system could improve reliability, performance, and enable advanced features like message retry, batch processing, and better error handling.

**** Technical Requirements
- Asynchronous message processing with queue management
- Message retry mechanism for failed operations
- Priority-based message handling (user messages vs system messages)
- Queue persistence for reliability across server restarts
- Real-time status updates for message processing states
- Dead letter queue for permanently failed messages
- Queue monitoring and analytics dashboard

**** Implementation Approach
1. **Core Queue Infrastructure**
   - Implement Redis-based message queue (Bull or BullMQ)
   - Create message job types (user message, AI response, export, etc.)
   - Add queue workers for different message types
   - Implement job retry logic with exponential backoff

2. **Message Processing Pipeline**
   - Queue user messages instead of immediate processing
   - Process AI responses asynchronously with progress tracking
   - Handle message dependencies (responses depend on user messages)
   - Add message validation and sanitization in queue workers

3. **User Experience Enhancements**
   - Real-time message status updates (queued, processing, completed, failed)
   - Optimistic UI updates with queue status indicators
   - Message retry UI for failed messages
   - Queue position and estimated processing time

4. **Advanced Features**
   - Batch processing for export operations
   - Priority queues for premium users or urgent messages
   - Message scheduling (delayed sending)
   - Queue-based rate limiting per user/session

**** Benefits
- **Improved Reliability**: Messages won't be lost during server issues
- **Better Performance**: Non-blocking message processing
- **Enhanced UX**: Clear status indicators and retry mechanisms  
- **Scalability**: Queue workers can be scaled independently
- **Advanced Features**: Enables batch operations and scheduling
- **Monitoring**: Detailed insights into message processing patterns

**** Priority Level: ðŸŸ¡ MEDIUM
**** Complexity Estimate: Complex (3-4 weeks)
**** Dependencies: Redis infrastructure, message processing refactor
**** Acceptance Criteria
- [ ] Messages are queued and processed asynchronously
- [ ] Real-time status updates for message processing
- [ ] Failed message retry mechanism implemented
- [ ] Queue monitoring dashboard available
- [ ] Message processing is more reliable than current system
- [ ] Performance improvement measurable (faster response times)
- [ ] Queue persistence survives server restarts
- [ ] Dead letter queue handling implemented
**** Related Files
- lib/messageQueue.ts (new - queue management)
- lib/queueWorkers.ts (new - job processing workers)
- contexts/MessageQueueContext.tsx (new - queue state management)
- hooks/useMessageQueue.ts (new - queue status hook)
- app/components/MessageStatusIndicator.tsx (new - queue status UI)
- app/api/queue/route.ts (new - queue management API)
- app/admin/queue/page.tsx (new - queue monitoring dashboard)

** ðŸŸ¢ LOW Priority

*** PWA Icons Missing (404 Errors)
**** Problem Statement
Manifest.json references icons in `/icons/` directory that don't exist, causing 404 errors for PWA functionality.

**** Implementation Approach
Create missing PWA icons from existing rubber duck logos in various required sizes (72x72 to 512x512).

*** Optimize Message Options/Buttons
**** Problem Statement
Message action buttons (copy, retry, star, tag, export) need optimization for better performance and user experience.

**** Implementation Approach
Review and optimize button rendering, mobile touch targets, visual design, and state management.

*** Optimize Starring System
**** Problem Statement
Stars API generates 409 conflict responses (functionality works but logs conflicts). System needs performance and UX improvements.

**** Technical Details
- 409 conflict responses in stars API endpoints
- Potential optimization areas: caching, optimistic updates, bulk operations
- Component interface recently updated but may need further refinement

*** Export Tooltip Z-Index Issue
Minor UI issue with tooltip layering in export functionality.

*** Copy Button on Messages Issue  
Copy button functionality needs refinement or fixes.

** ðŸ”µ RESEARCH

*** Claude Code Sub-Agent Integration
**** Problem Statement
Investigate why Claude Code isn't using defined custom AI agents properly.

**** Research Areas
- Agent recognition system
- Integration points
- Configuration requirements

*** Vercel Pro Upgrade Evaluation
**** Problem Statement
Consider Vercel Pro upgrade for separate deployment environments instead of current developâ†’production workflow.

**** Research Areas  
- Cost-benefit analysis
- Feature comparison
- Deployment environment separation capabilities

* Recently Added Items (Session Notes)
Items added during current development session but not yet prioritized:

- Mobile hamburger menu scroll optimization
- Mobile hamburger menu not closing  
- Mobile dark mode switcher
- Mobile sidebar left menu scrollability in sections
- Session header layout consolidation (partially addressed)

* Archive Reference
Completed items moved to: `docs/COMPLETED_BACKLOG.org`