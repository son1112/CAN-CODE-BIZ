#+TITLE: Rubber Ducky Live - Performance Optimization Plan
#+AUTHOR: Development Team
#+DATE: 2025-08-16
#+STARTUP: overview

* ðŸš¨ Current Performance Issues

** Observed Problems
- Input lag/delay when typing in text input with long conversation history
- Large DOM tree with complex message rendering
- Multiple re-renders on every keystroke
- Heavy FormattedMessage component processing for each message

** Root Causes Identified

*** 1. Expensive Message Rendering (PRIMARY ISSUE)
- Each message uses FormattedMessage component with complex regex processing
- Real-time markdown/formatting processing for every message on every render
- No memoization of formatted content
- Heavy inline style calculations

*** 2. Large DOM Tree
- All messages rendered simultaneously (no virtualization)
- Complex nested DOM structure for each message
- Expensive CSS-in-JS calculations per message

*** 3. Re-render Cascades
- Input state changes trigger full chat interface re-renders
- No React.memo usage on expensive components
- Missing useMemo/useCallback optimizations

*** 4. Context Over-usage
- Multiple context providers cause unnecessary re-renders
- Large context values trigger wide component updates

* ðŸŽ¯ Optimization Strategy (Priority Order)

** Phase 1: Immediate Wins (Input Responsiveness)
*** 1. Memoize FormattedMessage Component
- Add React.memo to FormattedMessage
- Cache formatted content with useMemo
- Prevent re-processing on parent re-renders

*** 2. Optimize Input Handling
- Debounce input processing
- Separate input state from message rendering
- Use uncontrolled input with refs for better performance

*** 3. Add Component Memoization
- Memo ChatInterface sub-components
- Optimize StarButton and other repeated components

** Phase 2: Message Virtualization (Major Performance Boost)
*** 1. Implement Virtual Scrolling
- Use react-window or react-virtualized
- Render only visible messages
- Maintain scroll position

*** 2. Message Chunking
- Lazy load older messages
- Implement pagination for conversation history

** Phase 3: Rendering Optimizations
*** 1. Reduce DOM Complexity
- Simplify message structure
- Remove unnecessary wrapper elements
- Optimize CSS selectors

*** 2. Pre-compute Heavy Operations
- Cache formatted message content
- Pre-process markdown during message creation
- Store computed styles

** Phase 4: Advanced Optimizations
*** 1. Web Workers
- Move heavy text processing to web workers
- Background markdown parsing

*** 2. Code Splitting
- Lazy load heavy components
- Split FormattedMessage features

* ðŸ“‹ Implementation Plan

** Immediate Actions (Next 30 minutes)

*** 1. Memoize FormattedMessage Component
#+BEGIN_SRC typescript
// Add React.memo and useMemo to FormattedMessage.tsx
const FormattedMessage: React.FC<FormattedMessageProps> = React.memo(({ content, textSizeClass, expandedView = false }) => {
  const formattedContent = useMemo(() => {
    return formatMessage(content);
  }, [content, textSizeClass, expandedView]);
  
  return <div className={textSizeClass}>{formattedContent}</div>;
});
#+END_SRC

*** 2. Optimize Input Component
#+BEGIN_SRC typescript
// Separate input state and add debouncing
const [debouncedInput, setDebouncedInput] = useState('');
const inputRef = useRef<HTMLTextAreaElement>(null);

const handleInputChange = useMemo(() => 
  debounce((value: string) => {
    setDebouncedInput(value);
  }, 100), []
);
#+END_SRC

*** 3. Add Message List Memoization
#+BEGIN_SRC typescript
// Memoize the entire message list rendering
const MessageList = React.memo(({ messages, isStreaming, collapsedMessages }) => {
  return (
    <div className="space-y-8">
      {messages.map((message, index) => (
        <MemoizedMessage 
          key={message.id}
          message={message}
          isStreaming={isStreaming && index === messages.length - 1}
          isCollapsed={collapsedMessages.has(message.id)}
        />
      ))}
    </div>
  );
});
#+END_SRC

** Short-term Actions (Next 2 hours)

*** 1. Implement Basic Virtualization
- Add react-window dependency
- Create VirtualizedMessageList component
- Maintain scroll position during updates

*** 2. Optimize Context Usage
- Split large contexts into smaller, focused ones
- Use context selectors to prevent unnecessary re-renders

*** 3. Add Performance Monitoring
- Implement React DevTools Profiler integration
- Add performance markers for key operations

** Medium-term Actions (Next sprint)

*** 1. Message Caching System
- Cache formatted messages in localStorage/IndexedDB
- Implement cache invalidation strategy

*** 2. Background Processing
- Move heavy text processing to web workers
- Implement progressive enhancement for formatting

* ðŸ”§ Specific Code Changes

** File: app/components/FormattedMessage.tsx
#+BEGIN_SRC typescript
// Performance-optimized version
'use client';

import React, { useMemo } from 'react';

interface FormattedMessageProps {
  content: string;
  textSizeClass: string;
  expandedView?: boolean;
}

const FormattedMessage: React.FC<FormattedMessageProps> = React.memo(({ 
  content, 
  textSizeClass, 
  expandedView = false 
}) => {
  // Memoize the expensive formatting operation
  const formattedContent = useMemo(() => {
    return formatMessage(content);
  }, [content, textSizeClass, expandedView]);

  return (
    <div className={`formatted-message ${textSizeClass}`}>
      {formattedContent}
    </div>
  );
});

FormattedMessage.displayName = 'FormattedMessage';

export default FormattedMessage;
#+END_SRC

** File: app/components/ChatInterface.tsx - Input Optimization
#+BEGIN_SRC typescript
// Optimize input handling
const ChatInterface = () => {
  const [inputValue, setInputValue] = useState('');
  const inputRef = useRef<HTMLTextAreaElement>(null);
  
  // Debounce input processing
  const handleInputChange = useCallback(
    debounce((value: string) => {
      // Only update derived state, not the input value itself
      setInputValue(value);
    }, 50),
    []
  );

  // Use uncontrolled input for better performance
  const handleInputKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      const value = inputRef.current?.value || '';
      if (value.trim()) {
        sendMessage(value.trim());
        if (inputRef.current) {
          inputRef.current.value = '';
        }
      }
    }
  }, [sendMessage]);

  return (
    <textarea
      ref={inputRef}
      onChange={(e) => handleInputChange(e.target.value)}
      onKeyDown={handleInputKeyDown}
      // ... other props
    />
  );
};
#+END_SRC

* ðŸ“Š Performance Monitoring

** Metrics to Track
- Time to first meaningful paint (TTFMP)
- Input lag measurement
- Message rendering time
- Total DOM nodes
- Memory usage

** Tools to Use
- React DevTools Profiler
- Chrome Performance tab
- Web Vitals monitoring
- Bundle analyzer

** Performance Targets
- Input lag: < 16ms (60fps)
- Message render time: < 50ms
- Memory usage: < 100MB for 1000 messages
- Bundle size: < 500KB gzipped

* ðŸš€ Expected Results

** Phase 1 Improvements
- 50-70% reduction in input lag
- 30-40% fewer re-renders
- Better user experience for typing

** Phase 2 Improvements  
- Support for unlimited message history
- Consistent performance regardless of conversation length
- 80-90% reduction in DOM nodes

** Phase 3 Improvements
- Near-instant message rendering
- Optimized memory usage
- Production-ready performance

* ðŸ”„ Implementation Status

** âœ… Analysis Complete
- [X] Identified performance bottlenecks
- [X] Created optimization plan
- [X] Prioritized improvements

** âœ… Phase 1 Complete
- [X] FormattedMessage memoization
- [ ] Input optimization
- [ ] Component memoization

** ðŸ”´ Pending
- [ ] Virtual scrolling implementation
- [ ] Message caching system
- [ ] Web worker integration
- [ ] Performance monitoring setup

* ðŸ“ Notes

** Technical Considerations
- Maintain existing functionality during optimization
- Ensure accessibility is preserved
- Test on various devices and network conditions
- Consider SEO impact of changes

** Risk Mitigation
- Implement changes incrementally
- Add performance regression tests
- Maintain fallbacks for critical features
- Monitor real-world performance metrics