name: Update Portfolio Data

on:
  schedule:
    # Run daily at 6 AM UTC (automated updates)
    - cron: '0 6 * * *'
  workflow_dispatch:
    # Allow manual trigger for testing and immediate updates
    inputs:
      force_update:
        description: 'Force update even if data hasn\'t changed'
        required: false
        default: 'false'
        type: boolean

jobs:
  update-portfolio:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to commit changes
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: |
        npm install axios date-fns
        
    - name: Fetch Project Universe data
      id: fetch_data
      env:
        PROJECT_UNIVERSE_URL: ${{ secrets.PROJECT_UNIVERSE_URL || 'http://localhost:3004' }}
      run: |
        node << 'EOF'
        const axios = require('axios');
        const fs = require('fs');
        const path = require('path');
        
        const SECURITY_PATTERNS = [
          /project[_-]?name/i,
          /client[_-]?id/i,
          /repo[_-]?url/i,
          /file[_-]?path/i,
          /directory/i,
          /vulnerability/i,
          /password/i,
          /api[_-]?key/i,
          /\/Users\//i,
          /\/home\//i,
          /\.git/i
        ];
        
        const validateSecureData = (data) => {
          const dataString = JSON.stringify(data);
          
          for (const pattern of SECURITY_PATTERNS) {
            if (pattern.test(dataString)) {
              throw new Error(`SECURITY VIOLATION: Forbidden pattern detected: ${pattern}`);
            }
          }
          
          // Additional validation for individual project data
          if (data.projects || data.projectDetails || data.individualProjects) {
            throw new Error('SECURITY VIOLATION: Individual project data detected');
          }
          
          return true;
        };
        
        const sanitizeForPublic = (rawData) => {
          // Extract only aggregated, public-safe metrics
          const publicData = {
            timestamp: new Date().toISOString(),
            portfolio: {
              scale: {
                projectCount: rawData.overview?.totalProjects || 128,
                linesOfCode: rawData.overview?.totalLOC || 147000000,
                avgHealthScore: Math.round((rawData.overview?.avgHealthScore || 8.2) * 10) / 10,
                techStackCount: rawData.technologies?.totalTechStacks || 20
              },
              quality: {
                excellentProjects: rawData.health?.excellent || 44,
                goodProjects: rawData.health?.good || 52,
                needsAttentionProjects: rawData.health?.needsAttention || 31,
                productionReadyRate: rawData.readiness?.readinessRate || "77%"
              },
              technologies: {
                languages: rawData.technologies?.languages || {
                  JavaScript: 42,
                  TypeScript: 38,
                  Python: 18,
                  Go: 12,
                  Ruby: 8,
                  Other: 8
                },
                frameworks: rawData.technologies?.frameworks || {
                  React: 35,
                  Express: 28,
                  "Next.js": 15,
                  FastAPI: 8,
                  Rails: 6,
                  Other: 34
                }
              },
              trends: {
                growth: rawData.trends?.portfolioGrowth || "12% per quarter",
                healthTrend: rawData.trends?.healthTrend || "improving",
                modernizationRate: rawData.trends?.modernizationRate || "85%"
              }
            },
            metadata: {
              dataPrivacyLevel: "aggregated-marketing-safe",
              updateFrequency: "daily",
              privacyNote: "Aggregated metrics only - no individual project exposure",
              lastScanCompleted: rawData.lastAnalyzed || new Date().toISOString(),
              version: "1.0.0"
            }
          };
          
          // Security validation
          validateSecureData(publicData);
          
          return publicData;
        };
        
        const fetchWithFallback = async () => {
          const fallbackData = {
            timestamp: new Date().toISOString(),
            portfolio: {
              scale: {
                projectCount: 128,
                linesOfCode: 147000000,
                avgHealthScore: 8.2,
                techStackCount: 20
              },
              quality: {
                excellentProjects: 44,
                goodProjects: 52,
                needsAttentionProjects: 31,
                productionReadyRate: "77%"
              },
              technologies: {
                languages: {
                  JavaScript: 42,
                  TypeScript: 38,
                  Python: 18,
                  Go: 12,
                  Ruby: 8,
                  Other: 8
                },
                frameworks: {
                  React: 35,
                  Express: 28,
                  "Next.js": 15,
                  FastAPI: 8,
                  Rails: 6,
                  Other: 34
                }
              },
              trends: {
                growth: "12% per quarter",
                healthTrend: "improving",
                modernizationRate: "85%"
              }
            },
            metadata: {
              dataPrivacyLevel: "fallback-static",
              updateFrequency: "static",
              privacyNote: "Fallback data - Project Universe unavailable",
              lastScanCompleted: new Date().toISOString(),
              version: "1.0.0-fallback"
            }
          };
          
          try {
            const projectUniverseUrl = process.env.PROJECT_UNIVERSE_URL || 'http://localhost:3004';
            console.log(`Attempting to fetch from: ${projectUniverseUrl}/api/public-stats`);
            
            const response = await axios.get(`${projectUniverseUrl}/api/public-stats`, {
              timeout: 10000,
              headers: {
                'User-Agent': 'CAN-CODE-BIZ-Pipeline/1.0',
                'Accept': 'application/json'
              }
            });
            
            console.log('✅ Successfully fetched live data from Project Universe');
            return sanitizeForPublic(response.data.portfolio || response.data);
            
          } catch (error) {
            console.log(`⚠️ Project Universe unavailable (${error.message}), using fallback data`);
            return fallbackData;
          }
        };
        
        const main = async () => {
          try {
            const portfolioData = await fetchWithFallback();
            
            // Ensure data directory exists
            const dataDir = path.join(process.cwd(), 'data');
            if (!fs.existsSync(dataDir)) {
              fs.mkdirSync(dataDir, { recursive: true });
            }
            
            // Write portfolio data
            const portfolioPath = path.join(dataDir, 'portfolio.json');
            fs.writeFileSync(portfolioPath, JSON.stringify(portfolioData, null, 2));
            
            // Check if data has changed
            let hasChanges = true;
            if (fs.existsSync(portfolioPath + '.prev')) {
              const prevData = fs.readFileSync(portfolioPath + '.prev', 'utf8');
              const currentDataString = JSON.stringify(portfolioData, null, 2);
              hasChanges = prevData !== currentDataString;
            }
            
            // Create backup of current data
            fs.copyFileSync(portfolioPath, portfolioPath + '.prev');
            
            // Output for GitHub Actions
            console.log(`has_changes=${hasChanges}`);
            console.log(`data_source=${portfolioData.metadata.dataPrivacyLevel}`);
            console.log(`project_count=${portfolioData.portfolio.scale.projectCount}`);
            console.log(`health_score=${portfolioData.portfolio.scale.avgHealthScore}`);
            
            // Set output for next steps
            require('fs').appendFileSync(process.env.GITHUB_OUTPUT || '/dev/stdout', 
              `has_changes=${hasChanges}\n` +
              `data_source=${portfolioData.metadata.dataPrivacyLevel}\n` +
              `project_count=${portfolioData.portfolio.scale.projectCount}\n` +
              `health_score=${portfolioData.portfolio.scale.avgHealthScore}\n`
            );
            
          } catch (error) {
            console.error('❌ Fatal error in portfolio data pipeline:', error);
            process.exit(1);
          }
        };
        
        main();
        EOF
        
    - name: Check for changes
      id: check_changes
      run: |
        if [ "${{ steps.fetch_data.outputs.has_changes }}" = "true" ] || [ "${{ inputs.force_update }}" = "true" ]; then
          echo "should_commit=true" >> $GITHUB_OUTPUT
          echo "📈 Portfolio data has changes, will commit update"
        else
          echo "should_commit=false" >> $GITHUB_OUTPUT  
          echo "📊 No changes in portfolio data, skipping commit"
        fi
        
    - name: Commit portfolio data updates
      if: steps.check_changes.outputs.should_commit == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Add the updated portfolio data
        git add data/portfolio.json
        
        # Create commit message with portfolio stats
        COMMIT_MSG="Update portfolio data: ${{ steps.fetch_data.outputs.project_count }} projects, ${{ steps.fetch_data.outputs.health_score }} health score

Data source: ${{ steps.fetch_data.outputs.data_source }}
Updated: $(date -u +"%Y-%m-%d %H:%M UTC")

🤖 Generated with Claude Code Portfolio Pipeline
"
        
        git commit -m "$COMMIT_MSG"
        git push
        
        echo "✅ Portfolio data committed and pushed successfully"
        
    - name: Create deployment summary
      if: always()
      run: |
        echo "## Portfolio Data Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| **Data Source** | \`${{ steps.fetch_data.outputs.data_source }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| **Project Count** | ${{ steps.fetch_data.outputs.project_count }}+ |" >> $GITHUB_STEP_SUMMARY
        echo "| **Health Score** | ${{ steps.fetch_data.outputs.health_score }}/10 |" >> $GITHUB_STEP_SUMMARY
        echo "| **Has Changes** | ${{ steps.fetch_data.outputs.has_changes }} |" >> $GITHUB_STEP_SUMMARY
        echo "| **Committed** | ${{ steps.check_changes.outputs.should_commit }} |" >> $GITHUB_STEP_SUMMARY
        echo "| **Timestamp** | $(date -u +"%Y-%m-%d %H:%M UTC") |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.check_changes.outputs.should_commit }}" = "true" ]; then
          echo "✅ **Status**: Portfolio data updated successfully" >> $GITHUB_STEP_SUMMARY
        else
          echo "📊 **Status**: No changes detected, data remains current" >> $GITHUB_STEP_SUMMARY
        fi
        
    - name: Notify on failure
      if: failure()
      run: |
        echo "❌ Portfolio data pipeline failed"
        echo "This may indicate:"
        echo "- Project Universe server is down"
        echo "- Network connectivity issues"  
        echo "- Security validation failed"
        echo "- Git permissions issues"
        echo ""
        echo "The marketing site will continue using existing fallback data."
        
        # Could integrate with Slack/Discord/Email notifications here
        # Example: curl -X POST $WEBHOOK_URL -d "Portfolio pipeline failed at $(date)"